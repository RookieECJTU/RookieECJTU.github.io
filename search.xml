<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2022/09/19/linux-chang-yong-ming-ling/"/>
      <url>/2022/09/19/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="常用目录"><a href="#常用目录" class="headerlink" title="常用目录"></a>常用目录</h2><table><thead><tr><th>目录名</th><th>说明</th></tr></thead><tbody><tr><td>/</td><td>根目录,一般根目录下只存放目录，有且只有一个根目录</td></tr><tr><td>/home</td><td>家目录，系统默认的家目录，新增用户账号时，用户的家目录都存放在此目录下</td></tr><tr><td>/root</td><td>系统管理员root的家目录</td></tr><tr><td>/bin/usr/bin</td><td>可执行二进制文件的目录</td></tr><tr><td>/etc</td><td>系统配置文件存放的目录</td></tr><tr><td>/mnt /media</td><td>光盘默认挂载点</td></tr><tr><td>/tmp</td><td>一般用户或正在执行的程序临时存放文件的目录</td></tr><tr><td>/var</td><td>这个目录中存放着不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下，包括各种日志文件</td></tr></tbody></table><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><ol><li>pwd命令<blockquote><p><strong>功能</strong>：显示用户当前所在目录</p></blockquote></li></ol><p><strong>格式</strong>： pwd<br>2. ls命令</p><blockquote><p><strong>功能</strong>：对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息</p></blockquote><p><strong>格式</strong>： ls [选项][目录或文件]</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">ls</span> -a  <span class="token comment"># 查看当前目录霞的文件，包括隐藏文件</span><span class="token function">ls</span> -l  <span class="token comment"># 长格式显示文件</span><span class="token function">ls</span> -lh <span class="token comment"># 以方便阅读的长格式显示</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>cd命令<blockquote><p><strong>功能</strong>：改变工作目录。将当前工作目录改变到指定的目录下</p></blockquote></li></ol><p><strong>格式</strong>：cd 目录名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> /  <span class="token comment"># 切换到根目录</span><span class="token builtin class-name">cd</span> ~  <span class="token comment"># 切换到家目录</span><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span> <span class="token comment"># 切换到上一级目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p>man命令</p><blockquote><p><strong>功能</strong>：访问Linux手册页</p></blockquote></li><li><p>grep命令</p><blockquote><p><strong>功能</strong>：用于查找文件里符合条件的字符串，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等</p></blockquote></li></ol><p><strong>格式</strong>：grep [选项] ‘查找字符串’ 文件名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">grep</span> <span class="token string">'MANPATH'</span> /etc/man.config <span class="token comment"># 取出文件/etc/man.config中包含MANPATH的行</span><span class="token function">ps</span> -aux <span class="token operator">|</span> <span class="token function">grep</span> go   <span class="token comment"># 查看go运行进程</span><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> nginx <span class="token comment"># 查看nginx的进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li>find命令<blockquote><p><strong>功能</strong>：用来指定目录下查找文件</p></blockquote></li></ol><p><strong>格式</strong>：grep [选项] ‘查找字符串’ 文件名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">find</span> / -name <span class="token function">passwd</span>     <span class="token comment"># 查找文件名为passwd的文件</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -size +12k       <span class="token comment"># 查找当前目录中大于12KB的文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="7"><li>chmod命令<blockquote><p><strong>功能</strong>：控制用户对文件的权限的命令</p></blockquote></li></ol><p><strong>格式</strong>：chmod[选项] 文件名</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>赋予读取权限</td></tr><tr><td>-w</td><td>赋予写入权限</td></tr><tr><td>-x</td><td>赋予执行权限</td></tr><tr><td>777</td><td>赋予可读、可写、可执行权限（读：4，写：2，执行：1）</td></tr></tbody></table><p><strong>权限说明</strong>：（例：-rw-r–r-x 的权限为645）</p><ul><li>权限显示位一共为10位，分为四段，从第二位算起，每三个一组</li><li>第1位代表文件类型（-表示为普通文件）</li><li>第2-4位代表文件所属用户拥有的权限（rw-：4+2=6）</li><li>第5-7位代表该用户所属组拥有的权限（-r–：4）</li><li>第8-10位代表其他用户拥有的权限（r-x：4+1=5）</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chmod</span> 0755 <span class="token function">file</span>     <span class="token comment"># 把file的文件权限改变成-rxwr-xr-x</span><span class="token function">chmod</span> g+w <span class="token function">file</span>      <span class="token comment"># 向file的文件权限中加入用户组可写权限</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="8"><li>ps命令<blockquote><p><strong>功能</strong>：用来列出系统中当前正在运行的那些进程，类似于windows的任务管理器</p></blockquote></li></ol><p><strong>格式</strong>：ps[选项]</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">ps</span> -aux <span class="token comment"># 查看系统所有的进程数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="9"><li>kill命令<blockquote><p><strong>功能</strong>：用于删除执行中的程序或工作</p></blockquote></li></ol><p><strong>格式</strong>：kill [选项]/[信号] 进程号</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">kill</span> -9 <span class="token number">1282</span> <span class="token comment"># 强制停止</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="10"><li>tail命令<blockquote><p><strong>功能</strong>：用于查看文件的内容</p></blockquote></li></ol><p><strong>格式</strong>：tail [选项][文件]</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">tail</span> -f notes.log <span class="token comment"># 实时查看notes.log文件最后10行</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><ol><li>mkdir命令</li></ol><blockquote><p><strong>功能</strong>：创建空目录</p></blockquote><p><strong>格式</strong>：mkdir [选项][路径] 文件名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mkdir</span> <span class="token builtin class-name">test</span> <span class="token comment"># 创建一个test文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>rmdir命令</li></ol><blockquote><p><strong>功能</strong>：删除空目录，不能删除非空目录，不能删除文件</p></blockquote><p><strong>格式</strong>：rmdir [-p][路径] 目录名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">rmdir</span> -p <span class="token builtin class-name">test</span> <span class="token comment"># 删除test目录，如果父目录也是空的会一并删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>touch命令</li></ol><blockquote><p><strong>功能</strong>：新建空文件</p></blockquote><p><strong>格式</strong>：touch [路径] 文件名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">touch</span> <span class="token builtin class-name">.</span> file1 file2 <span class="token comment"># 当前目录下新建file1、file2文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>rm命令</li></ol><blockquote><p><strong>功能</strong>：删除文件或目录</p></blockquote><p><strong>格式</strong>：rm [选项] 文件名</p><p><strong>rm和rmdir的区别</strong>：</p><ul><li>rm有选项，rmdir没有选项</li><li>rmdir只能删除空目录，不能删除文件</li><li>rm带上选项-r可以删除非空目录</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">rm</span> -f <span class="token function">file</span> <span class="token comment"># 强制删除file文件</span><span class="token function">rm</span> -r <span class="token function">dir</span>  <span class="token comment"># 删除dir目录下所有文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="5"><li>mv命令<blockquote><p><strong>功能</strong>：移动文件或者文件重命名</p></blockquote></li></ol><p><strong>格式</strong>：mv [选项][路径] 旧文件名 [新路径][新文件名]</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mv</span> file1 file2 file3 <span class="token function">dir</span> <span class="token comment"># 把文件file1、file2、file3移动到目录dir中</span><span class="token function">mv</span> file1 file2 <span class="token comment"># 把文件file1重命名为file2</span><span class="token function">mv</span> ./dist/* ./ <span class="token comment"># 把当前这个dist文件夹里的内容剪切出来，到当前目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li>cp命令</li></ol><blockquote><p><strong>功能</strong>：复制文件或目录</p></blockquote><p><strong>格式</strong>：cp [选项][路径] 旧文件名 [新路径][新文件名]</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cp</span> -r file1 file2  <span class="token comment"># 连同文件的所有特性把文件file1复制成文件file2</span><span class="token function">cp</span> file1 file2 file3 <span class="token function">dir</span> <span class="token comment"># 把文件file1、file2、file3复制到目录dir中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="7"><li>cat命令<blockquote><p><strong>功能</strong>：查看目标文件的内容</p></blockquote></li></ol><p><strong>格式</strong>：cat [选项] 文件名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cat</span> <span class="token function">file</span>  <span class="token comment"># 查看file文件内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="8"><li>vim</li></ol><p>常用：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">vim</span> test.txt        <span class="token comment"># 查看该目录下的文件</span><span class="token function">vim</span> /home/test.txt  <span class="token comment"># 查看该路径下的文件</span> insert插入按钮（dele按钮的上面）    <span class="token comment"># 这个按钮就可以进行文件编写</span>esc退出按钮（键盘左上角）   <span class="token comment"># 这个按钮是编写完后退出</span>:wq      <span class="token comment"># 输入这个是保存刚刚更改的文件</span>:wq<span class="token operator">!</span>     <span class="token comment"># 输入这个是强行保存刚刚更改的文件--建议习惯使用这个</span>:q      <span class="token comment"># 输入这个是不保存退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="nginx的基本启动"><a href="#nginx的基本启动" class="headerlink" title="nginx的基本启动"></a>nginx的基本启动</h2><p>找到nginx的sbin目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止（或者kill该进程）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./nginx -s stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检测nginx配置文件是否有错误</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nginx -t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁的四个必要条件和解决方法</title>
      <link href="/2022/09/18/si-suo-de-si-ge-bi-yao-tiao-jian-he-jie-jue-fang-fa/"/>
      <url>/2022/09/18/si-suo-de-si-ge-bi-yao-tiao-jian-he-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁概念和产生原理"><a href="#死锁概念和产生原理" class="headerlink" title="死锁概念和产生原理"></a>死锁概念和产生原理</h2><p><strong>概念</strong>：多个并发进程争夺系统资源而产生相互等待的现象<br><strong>原理</strong>：当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁<br><strong>本质原因</strong>：</p><ol><li>系统资源有限</li><li>进程推进顺序不合理</li><li>资源分配不合理</li></ol><h2 id="死锁产生的4个必要条件"><a href="#死锁产生的4个必要条件" class="headerlink" title="死锁产生的4个必要条件"></a>死锁产生的4个必要条件</h2><ol><li><strong>互斥</strong>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束</li><li><strong>占有且等待</strong>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源</li><li><strong>不可抢占</strong>：别人占有了某项资源，你不能因为自己也要该资源，就去把别人的资源抢过来</li><li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的循环等待资源关系(比如一个进程集合，A在等B，B在等C，C在等A)</li></ol><h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p> 产生死锁需要四个条件，那么，只要这四个条件中至少有一个条件得不到满足，就不可能发生死锁了。由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以，主要是破坏产生死锁的其他三个条件。</p><ol><li>破坏“占有且等待”条件<br> 方法1：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。<br> 优点：简单易实施且安全。<br> 缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。<br>          使进程经常发生饥饿现象。<br> 方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。</li><li>破坏“不可抢占”条件</li><li>当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。<br>  该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。</li><li>破坏“循环等待”条件<br>采用资源有序分配,将系统中的所有资源顺序编号，将紧缺的，稀少的资源采用较大的编号（一个进程只有获得较小编号的进程才能申请较大编号的进程）</li></ol><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>死锁避免是利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。<br>两种避免办法：<br>    1、如果一个进程的请求会导致死锁，则不启动该进程<br>    2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。<br>避免死锁的具体实现通常利用银行家算法</p><blockquote><p><strong>银行家算法</strong><br>银行家算法的相关数据结构<br>    <strong>可利用资源向量Available</strong>：用于表示系统里边各种资源剩余的数目。由于系统里边拥有的资源通常都是有很多种（假设有m种），所以，我们用一个有m个元素的数组来表示各种资源。数组元素的初始值为系统里边所配置的该类全部可用资源的数目，其数值随着该类资源的分配与回收动态地改变。<br>    <strong>最大需求矩阵Max</strong>：用于表示各个进程对各种资源的额最大需求量。进程可能会有很多个（假设为n个），那么，我们就可以用一个nxm的矩阵来表示各个进程多各种资源的最大需求量<br>    <strong>分配矩阵Allocation</strong>：顾名思义，就是用于表示已经分配给各个进程的各种资源的数目。也是一个nxm的矩阵。<br>    <strong>需求矩阵Need</strong>：用于表示进程仍然需要的资源数目，用一个nxm的矩阵表示。系统可能没法一下就满足了某个进程的最大需求（通常进程对资源的最大需求也是只它在整个运行周期中需要的资源数目，并不是每一个时刻都需要这么多），于是，为了进程的执行能够向前推进，通常，系统会先分配个进程一部分资源保证进程能够执行起来。那么，进程的最大需求减去已经分配给进程的数目，就得到了进程仍然需要的资源数目了。</p></blockquote><p>死锁避免的优点：不需要死锁预防中的抢占和重新运行进程，并且比死锁预防的限制要少。<br>死锁避免的限制：<br>    - 必须事先声明每个进程请求的最大资源量<br>    - 考虑的进程必须无关的，也就是说，它们执行的顺序必须没有任何同步要求的限制<br>    - 分配的资源数目必须是固定的。<br>    - 在占有资源时，进程不能退出</p><h2 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h2><ol><li>抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。</li><li>终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。<ul><li>终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。</li><li>逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。一般根据如下几个方面来决定终止哪个进程：<blockquote><p>进程的优先级<br> 进程已运行时间以及运行完成还需要的时间<br> 进程已占用系统资源<br> 进程运行完成还需要的资源<br> 终止进程数目<br> 进程是交互还是批处理</p></blockquote></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang调度器GMP原理</title>
      <link href="/2022/09/18/golang-diao-du-qi-gmp-yuan-li/"/>
      <url>/2022/09/18/golang-diao-du-qi-gmp-yuan-li/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程及协程的区别</title>
      <link href="/2022/09/18/jin-cheng-xian-cheng-ji-xie-cheng-de-qu-bie/"/>
      <url>/2022/09/18/jin-cheng-xian-cheng-ji-xie-cheng-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="进程、线程和协程的概念"><a href="#进程、线程和协程的概念" class="headerlink" title="进程、线程和协程的概念"></a>进程、线程和协程的概念</h2><ul><li><strong>进程</strong>：是程序的一次执行过程，是系统资源分配和独立运行的最小单位</li><li><strong>线程</strong>：是进程的一个执行单元，是任务调度和系统执行的最小单位</li><li><strong>协程</strong>：是一种用户态的轻量级线程，协程的调度完全由用户控制</li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ol><li><strong>根本区别</strong>：进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位</li><li><strong>地址空间区别</strong>：每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li><strong>上下文切换开销区别</strong>：每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li></ol><h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><ol><li><strong>根本区别</strong>： 协程是用户态的轻量级线程，不受内核调度；线程是任务调度和系统执行的最小单位，需要内核调度。</li><li><strong>运行机制区别</strong>： 线程和进程是同步机制，而协程是异步机制。</li><li><strong>上下文切换开销区别</strong>： 线程运行状态切换及上下文切换需要内核调度，会消耗系统资源；而协程完全由程序控制，状态切换及上下文切换不需要内核参与。</li></ol><h2 id="Golang的goroutine调度机制"><a href="#Golang的goroutine调度机制" class="headerlink" title="Golang的goroutine调度机制"></a>Golang的goroutine调度机制</h2><p>参考我的文章<a href="http://gowzh.com/2022/09/18/golang-diao-du-qi-gmp-yuan-li/">Golang的goroutine调度机制</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的GC</title>
      <link href="/2022/09/18/go-de-gc/"/>
      <url>/2022/09/18/go-de-gc/</url>
      
        <content type="html"><![CDATA[<h2 id="Go的GC是怎么实现的"><a href="#Go的GC是怎么实现的" class="headerlink" title="Go的GC是怎么实现的"></a>Go的GC是怎么实现的</h2><ul><li><p><strong>GoV1.3</strong> - 普通标记清除法，整体过程需要启动STW，效率极低。</p></li><li><p><strong>GoV1.5</strong> - 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p></li><li><p><strong>GoV1.8</strong> -三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高</p></li></ul><h2 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h2><h3 id="GoV1-3"><a href="#GoV1-3" class="headerlink" title="GoV1.3"></a>GoV1.3</h3><h4 id="1-3之前："><a href="#1-3之前：" class="headerlink" title="1.3之前："></a>1.3之前：</h4><ul><li>STW暂停</li><li>标记根对象可达对象</li><li>清除未被标记对象</li><li>停止STW</li></ul><p><strong>标记-清除的缺点</strong></p><ul><li>STW（stop the world）过程中，CPU不执行用户代码，全部用于垃圾回收，程序出现卡顿。</li><li>标记清除需要扫描整个heap</li><li>清除数据会产生heap碎片</li></ul><h4 id="1-3优化："><a href="#1-3优化：" class="headerlink" title="1.3优化："></a>1.3优化：</h4><ul><li>STW暂停</li><li>标记根对象可达对象</li><li>停止STW</li><li>清除未被标记对象</li></ul><p>优化主要是将停止STW的步骤提前了异步，在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。<br>但无论怎么优化，Go V1.3都面临一个重要问题，就是mark-and-sweep算法会暂停整个程序。</p><h3 id="GoV1-5"><a href="#GoV1-5" class="headerlink" title="GoV1.5"></a>GoV1.5</h3><ol><li>所有的对象放到白色集合</li><li>遍历一次根对象，将被直接引用的对象标记为灰色</li><li>遍历所有的灰色节点，将可达的对象从白色标记为灰色，遍历之后的灰色节点标记为黑色。</li><li>由于并发特性，此刻外界向堆、栈中添加或者删除对象。在<strong>堆</strong>中的对象会触发<strong>屏障机制</strong>，而栈中的对象不会触发</li><li>由于屏障机制，会把堆中黑色对象添加的白色对象改成灰色，栈中的黑色对象添加白色对象依然是白色</li><li>循环第5步，直到没有灰色节点</li><li>在准备回收白色前，重新遍历扫描一次栈空间，加上STW暂停保护栈，防止外界干扰（有新的白色会被黑色对象引用），在STW中，将栈中的对象一次三色标记，直到没有灰色节点</li><li>停止STW，清除白色节点。</li></ol><h3 id="GoV1-8"><a href="#GoV1-8" class="headerlink" title="GoV1.8"></a>GoV1.8</h3><p>使用混合写屏障机制，流程和1.5一样，但有以下区别（不会对栈进行二次重复扫描，无需STW）<br>1、GC开始将栈上的对象全部扫描并标记为黑色（之后不需要进行二次重复扫描，无需STW）<br>2、GC期间，任何在栈上创建的新对象都会标记成黑色</p><h3 id="三色标记存在的问题"><a href="#三色标记存在的问题" class="headerlink" title="三色标记存在的问题"></a>三色标记存在的问题</h3><p>在三色标记法中，有以下两种情况会导致对象被GC“误杀”回收掉</p><blockquote><p>1: 一个白色对象被黑色对象引用 (白色被挂在黑色下)</p><p>2: 灰色对象与它之间的可达关系的白色对象遭到破坏 (灰色同时丢了该白色)<br>如果当以上两个条件同时满足时，就会出现对象丢失现象</p></blockquote><p>并且如果白色对象还有很多下游对象，也会一并清理掉。为了防止这种现象的发生，最简单的方式就是 STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是 STW 的过程有明显的资源浪费，对所有的用户程序都有很大影响。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高 GC 效率，减少 STW 时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h2 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h2><h2 id="“强-弱”三色不变式"><a href="#“强-弱”三色不变式" class="headerlink" title="“强-弱”三色不变式"></a>“强-弱”三色不变式</h2><p><em>强三色不变式</em>：不存在黑色对象引用到白色对象的指针。强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><p><em>弱三色不变式</em><br>所有被黑色对象引用的白色对象都处于灰色保护状态。弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p>为了遵循上述的两个方式，GC 算法演进到两种屏障方式，他们 “插入屏障”, “删除屏障”。</p><h3 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h3><p>当一个对象引用另外一个对象时，将另外一个对象标记为灰色，以此满足<strong>强三色不变性</strong>，不会存在黑色对象引用白色对象。</p><h3 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h3><p>在灰色对象删除对白色对象的引用时，将白色对象置为灰色，其实就是快照保存旧的引用关系，这叫STAB(snapshot-at-the-beginning),以此满足<strong>弱三色不变性</strong>。</p><h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>保证弱三色不变性；该写屏障会将覆盖的对象标记成灰色(删除写屏障)并在当前栈没有扫描时将新对象也标记成灰色(插入写屏障)：写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新建的对象都会被直接标记成黑色。</p><h3 id="屏障的作用"><a href="#屏障的作用" class="headerlink" title="屏障的作用"></a>屏障的作用</h3><ul><li>避免程序运行过程中，变量被误回收</li><li>减少STW的时间</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU算法实现</title>
      <link href="/2022/09/13/lru-suan-fa-shi-xian/"/>
      <url>/2022/09/13/lru-suan-fa-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>LRU是Least Recently Used 近期最少使用算法。 内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。什么是LRU算法？ LRU是Least Recently Used的缩写，即最近最久未使用，常用于页面置换算法，是为虚拟页式存储管理服务的。关于操作系统的内存管理，如何节省利用容量不大的内存为最多的进程提供资源，一直是研究的重要方向。而内存的虚拟存储管理，是现在最通用，最成功的方式—— 在内存有限的情况下，扩展一部分外存作为虚拟内存，真正的内存只存储当前运行时所用得到信息。这无疑极大地扩充了内存的功能，极大地提高了计算机的并发度。虚拟页式存储管理，则是将进程所需空间划分为多个页面，内存中只存放当前所需页面，其余页面放入外存的管理方式。然而，有利就有弊，虚拟页式存储管理减少了进程所需的内存空间，却也带来了运行时间变长这一缺点：进程运行过程中，不可避免地要把在外存中存放的一些信息和内存中已有的进行交换，由于外存的低速，这一步骤所花费的时间不可忽略。因而，采取尽量好的算法以减少读取外存的次数，也是相当有意义的事情。百度百科</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路：借助一个双向链表存放数据，获取和插入都会把节点移动到链表头部，如果缓存满了，将删除掉链表尾节点。还需要维护一个哈希表，value存放节点地址，这样操作节点就不需遍历链表，时间复杂度为o(1)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> LRUCache <span class="token keyword">struct</span> <span class="token punctuation">{</span>capacity <span class="token builtin">int</span>lruMap <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token operator">*</span>DLinkNodehead<span class="token punctuation">,</span> tail <span class="token operator">*</span>DLinkNode<span class="token punctuation">}</span><span class="token keyword">type</span> DLinkNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>key<span class="token punctuation">,</span> value <span class="token builtin">int</span>pre<span class="token punctuation">,</span> next <span class="token operator">*</span>DLinkNode<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Constructor</span><span class="token punctuation">(</span>capacity <span class="token builtin">int</span><span class="token punctuation">)</span> LRUCache <span class="token punctuation">{</span>cache <span class="token operator">:=</span> LRUCache<span class="token punctuation">{</span>capacity<span class="token punctuation">:</span> capacity<span class="token punctuation">,</span>head<span class="token punctuation">:</span> <span class="token operator">&amp;</span>DLinkNode<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>tail<span class="token punctuation">:</span> <span class="token operator">&amp;</span>DLinkNode<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>lruMap<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token operator">*</span>DLinkNode<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span>cache<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> cache<span class="token punctuation">.</span>tailcache<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> cache<span class="token punctuation">.</span>head<span class="token keyword">return</span> cache<span class="token punctuation">}</span><span class="token comment">// 获取数据</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span>this<span class="token punctuation">.</span><span class="token function">DelNode</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>this<span class="token punctuation">.</span><span class="token function">AddNodeToHead</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">return</span> this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token comment">// 添加或者更新数据</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">)</span> <span class="token function">Put</span><span class="token punctuation">(</span>key <span class="token builtin">int</span><span class="token punctuation">,</span> value <span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>node <span class="token operator">:=</span> <span class="token operator">&amp;</span>DLinkNode<span class="token punctuation">{</span>key<span class="token punctuation">:</span> key<span class="token punctuation">,</span> value<span class="token punctuation">:</span> value<span class="token punctuation">}</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> nodethis<span class="token punctuation">.</span><span class="token function">AddNodeToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">)</span> <span class="token operator">&gt;</span> this<span class="token punctuation">.</span>capacity <span class="token punctuation">{</span><span class="token function">delete</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">,</span> this<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>key<span class="token punctuation">)</span>this<span class="token punctuation">.</span><span class="token function">DelTailNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">}</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> valuethis<span class="token punctuation">.</span><span class="token function">DelNode</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>this<span class="token punctuation">.</span><span class="token function">AddNodeToHead</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>lruMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 添加节点到链表头部</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">)</span> <span class="token function">AddNodeToHead</span><span class="token punctuation">(</span>node <span class="token operator">*</span>DLinkNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>this<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> nodenode<span class="token punctuation">.</span>next <span class="token operator">=</span> this<span class="token punctuation">.</span>head<span class="token punctuation">.</span>nextthis<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> nodenode<span class="token punctuation">.</span>pre <span class="token operator">=</span> this<span class="token punctuation">.</span>head<span class="token punctuation">}</span><span class="token comment">// 删除节点</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">)</span> <span class="token function">DelNode</span><span class="token punctuation">(</span>node <span class="token operator">*</span>DLinkNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>node<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>nextnode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">.</span>pre<span class="token punctuation">}</span><span class="token comment">// 删除尾节点</span><span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>LRUCache<span class="token punctuation">)</span> <span class="token function">DelTailNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>this<span class="token punctuation">.</span><span class="token function">DelNode</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>pre<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top K的两种经典解法（堆/快排）与优劣比较</title>
      <link href="/2022/09/13/top-k-de-liang-chong-jing-dian-jie-fa-dui-kuai-pai-yu-you-lie-bi-jiao/"/>
      <url>/2022/09/13/top-k-de-liang-chong-jing-dian-jie-fa-dui-kuai-pai-yu-you-lie-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><p>在n个数中找出最小的k个数。例如，4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><h2 id="方法一：堆"><a href="#方法一：堆" class="headerlink" title="方法一：堆"></a>方法一：堆</h2><ul><li>时间复杂度O(n log k)</li><li>空间复杂度O(k)</li><li>思路：借助一个大小为K的最大堆（大顶堆）。将元素一次入堆，当堆的大小超过k时，将多出的元素从堆顶弹出。处理完所有元素之后，堆里存储的元素即为最小的K个元素。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 从数组中获取最小的k个元素</span><span class="token keyword">func</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&gt;</span> length <span class="token punctuation">{</span><span class="token keyword">return</span> res<span class="token punctuation">}</span>pq <span class="token operator">:=</span> <span class="token operator">&amp;</span>maxHeap<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>heap<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span>heap<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 遍历到的元素比堆顶元素小时，取出堆顶元素，将当前元素入堆</span><span class="token keyword">if</span> pq<span class="token punctuation">.</span><span class="token function">Peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>heap<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span>heap<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> heap<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span class="token comment">// 基于go interface实现最大堆</span><span class="token keyword">type</span> maxHeap <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>x <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>h <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">,</span> x<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>h<span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>h<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>h<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 查看堆顶元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：基于快速排序的数组划分"><a href="#方法二：基于快速排序的数组划分" class="headerlink" title="方法二：基于快速排序的数组划分"></a>方法二：基于快速排序的数组划分</h2><ul><li>时间复杂度O(n)，最坏情况为o(n^2)</li><li>空间复杂度O(log n)</li><li>思路：题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而快速排序的基准元素划分可完成此目标。<br>根据快速排序原理，会把比基准元素小的元素放左边，比基准元素大的放右边。假设基准元素下标为m，那么：<blockquote><ul><li>如果 k == m，则基准元素左边正好有且只有k个比基准小的元素</li><li>如果 k &lt; m，则基准左边小元素数量不够，只需要继续递归基准右边的元素</li><li>如果 k &gt; m，则基准左边元素超过了k个，只需要递归基准左边的元素即可</li></ul></blockquote></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 从数组中获取最小的k个元素</span><span class="token keyword">func</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&gt;</span> length <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">quick</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> start <span class="token operator">&gt;=</span> end <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 把第一个元素作为基准</span>pivot <span class="token operator">:=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span>i<span class="token punctuation">,</span>j <span class="token operator">:=</span> start<span class="token punctuation">,</span> end<span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token punctuation">{</span><span class="token comment">// 从右往左找小于基准的数字，大于则不处理。不取等会死循环</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">}</span><span class="token comment">// 从左往右找大于基准的数字，小于则不处理</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 如果存在大于基准的数或者小于基准的，移动到i位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 把基准放在i,j重合位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">// 如果k &lt; i 则需要把i右边的数组继续排序，如果 k &gt; i 则需要把i左边的数组继续排序</span><span class="token comment">// 如果k == i 则说明i左边正好有k个最小元素了，直接返回</span><span class="token keyword">if</span> k <span class="token operator">&lt;</span> i <span class="token punctuation">{</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> k <span class="token operator">&gt;</span> i <span class="token punctuation">{</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两种方法的优缺点比较"><a href="#两种方法的优缺点比较" class="headerlink" title="两种方法的优缺点比较"></a>两种方法的优缺点比较</h2><p>虽然方法二的时间复杂度优于方法一，但是快速排序算法有以下几点局限性</p><ol><li>方法二需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</li><li>算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的设计与实现-字典</title>
      <link href="/2022/09/02/redis-she-ji-yu-shi-xian-zi-dian/"/>
      <url>/2022/09/02/redis-she-ji-yu-shi-xian-zi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典，又称符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。<br>在字典中，一个键可以和一个值进行关联，每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或通过键来更新值，又或者根据键来删除整个键值对，等等。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Redis字典所使用的哈希表由dict.h/dictht结构定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>   <span class="token comment">// 哈希表数组 </span>  dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>  <span class="token comment">// 哈希表大小</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size   <span class="token comment">// 哈希表大小掩码，用于计算索引值</span>  <span class="token comment">// 总是等于size-1</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask   <span class="token comment">// 该哈希表已有节点的数量</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>table属性是一个数组，数组中的每个元素都是指向dict.h/dictEntry结构的指针</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis设计与实现-redis字符串实现</title>
      <link href="/2022/09/02/redis-she-ji-yu-shi-xian-redis-zi-fu-chuan-shi-xian/"/>
      <url>/2022/09/02/redis-she-ji-yu-shi-xian-redis-zi-fu-chuan-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis字符串实现"><a href="#一、Redis字符串实现" class="headerlink" title="一、Redis字符串实现"></a>一、Redis字符串实现</h2><p>Redis没有使用C语言传统的字符串表示（以空字符串结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。<br>例如，如果客户端执行命令</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">redis<span class="token operator">&gt;</span> SET msg <span class="token string">"hello world"</span>OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么Redis将在数据库中创建一个新的键值对，其中：</p><ul><li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg”的SDS</li><li>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串”hello world”的SDS</li></ul><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><p>每个sds.h/sdshdr结构表示一个SDS值：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>   <span class="token comment">// 记录buf数组中已使用字节的数量 </span>  <span class="token comment">// 等于SDS所保存字符串的长度 </span>  <span class="token keyword">int</span> len<span class="token punctuation">;</span>   <span class="token comment">// 记录buf数组中未使用字节的数量 </span>  <span class="token keyword">int</span> free<span class="token punctuation">;</span>   <span class="token comment">// 字节数组，用于保存字符串 </span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：SDS遵循C字符串以’\0’结尾的惯例，保存’\0’的一个字节空间不会计算在SDS的len属性里面，并且为’\0’分配额外的1字节空间以及添加’\0’到字符串末尾等操作都是由SDS函数自动完成的，所以这个空字符串对于SDS的使用者来说是完全透明的。遵循’\0’结尾的好处是SDS可以直接重用一部分C字符串函数库里面的函数。</p><h2 id="二、C字符串和SDS的区别"><a href="#二、C字符串和SDS的区别" class="headerlink" title="二、C字符串和SDS的区别"></a>二、C字符串和SDS的区别</h2><table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度Ｎ次必然需要执行Ｎ次内存重分配</td><td>修改字符串Ｎ次最多需要执行Ｎ次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本数据或者二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库的函数</td><td>可以使用一部分&lt;string.h&gt;库的函数</td></tr></tbody></table><h2 id="三、空间预分配和惰性空间释放"><a href="#三、空间预分配和惰性空间释放" class="headerlink" title="三、空间预分配和惰性空间释放"></a>三、空间预分配和惰性空间释放</h2><p>对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是N+1个字符长的数组。因为C字符串的长度和底层数组的长度之间存在这种关联性，所以每次增长或者缩短一个C字符串都需要对保存这个C字符串的数组进行一次内存重分配操作：</p><ul><li>如果程序执行增长字符串操作，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步会产生缓冲区溢出</li><li>如果程序执行缩短字符串操作，程序需要先通过内存重分配来释放不在使用的那部分空间——如果忘了这一步会产生内存泄露</li></ul><p>因为内存重分配涉及复杂的算法，并且可能需要执行系统的调用，所以它通常是一个比较耗时的操作。为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><h3 id="3-1-空间预分配"><a href="#3-1-空间预分配" class="headerlink" title="3.1 空间预分配"></a>3.1 空间预分配</h3><p>空间预分配用于优化SDS字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用的空间。<br>其中，额外分配的未使用空间数量由以下公式决定：</p><ul><li>如果对SDS进行修改之后，SDS的长度（即len属性的值）将小于1MB，那么程序分配和len属性相同的未使用空间，这时SDS的len属性的值将和free属性的值相同。例如：进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存’\0’）。</li><li>如果对SDS进行修改之后，SDS的长度大于1MB，那么程序将会分配1MB的未使用空间。例如：进行修改之后，SDS的len将变成30MB，那么程序也会分配1MB的未使用空间，SDS的buf数组的实际长度将变成30MB + 1MB + 1byte。</li></ul><p>在扩展SDS空间之前，SDS的API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用的空间，则无需执行内存重分配。</p><h3 id="3-2-惰性空间释放"><a href="#3-2-惰性空间释放" class="headerlink" title="3.2 惰性空间释放"></a>3.2 惰性空间释放</h3><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不会立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。<br>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p><h2 id="四、二进制安全"><a href="#四、二进制安全" class="headerlink" title="四、二进制安全"></a>四、二进制安全</h2><p>C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串不能包含’\0’,否则最先被程序读入的’\0’会被误认是字符串的结尾，这些限制使得C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。<br>SDS使用len属性的值而不是’\0’判断字符串是否结束，SDS API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式处理SDS存放在buf数组里的数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实现前中后序遍历构建二叉树</title>
      <link href="/2022/08/30/bian-li-er-cha-shu/"/>
      <url>/2022/08/30/bian-li-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 前序遍历（递归版）</span><span class="token comment">// 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</span><span class="token keyword">func</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 先放入根节点，然后递归左节点</span>res <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>root<span class="token punctuation">.</span>Val<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 然后递归右节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 前序遍历（迭代版）</span><span class="token comment">// 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树。借助栈来模拟递归</span><span class="token keyword">func</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 记录前序遍历结果</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 借助栈来模拟递归</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// 从栈中取出一个节点</span>node <span class="token operator">:=</span> stack<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token comment">// 放入根节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token comment">// 先左节点后右节点放入栈中,这样会”中-&gt;左-&gt;右“的顺序</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 后序遍历（递归版）</span><span class="token comment">// 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</span><span class="token keyword">func</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 先递归左节点</span><span class="token comment">// 然后递归右节点</span>res <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 然后放入根节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> root<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代版-1"><a href="#迭代版-1" class="headerlink" title="迭代版"></a>迭代版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 后序遍历（迭代版）</span><span class="token comment">// 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点。借助栈来模拟递归，逻辑和前序遍历一样，但需要反向生成结果数组。</span><span class="token keyword">func</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 记录前序遍历结果</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 借助栈来模拟递归</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// 从栈中取出一个节点</span>node <span class="token operator">:=</span> stack<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token comment">// 放入根节点，反向生成结果数组</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>node<span class="token punctuation">.</span>Val<span class="token punctuation">}</span><span class="token punctuation">,</span> res<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 先左节点后右节点放入栈中,这样会”中-&gt;右-&gt;左“的顺序，然后反向生成结果数字</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 中序遍历（递归版）</span><span class="token comment">// 中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</span><span class="token keyword">func</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 先递归左节点</span><span class="token comment">// 然后放入根节点</span>res <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token comment">// 然后递归右节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代版-2"><a href="#迭代版-2" class="headerlink" title="迭代版"></a>迭代版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 中序遍历（迭代版版）</span><span class="token comment">// 中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</span><span class="token comment">// 遍历顺序和处理节点的顺序不同，导致中序遍历和前序遍历和后序遍历都不一样。</span><span class="token comment">// 需要借助一个栈来记录遍历过的节点，需要一个指针来记录当前节点</span><span class="token keyword">func</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 创建一个栈来记录遍历过的节点</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 指针初始化指向根节点</span>cur <span class="token operator">:=</span> root<span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">if</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token comment">// 记录遍历过的节点</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token comment">// 当前指针指向左子节点</span>cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 取出栈顶元素</span>node <span class="token operator">:=</span> stack<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">// 放入结果数组中</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token comment">// 当前指针指向右子节点</span>cur <span class="token operator">=</span> node<span class="token punctuation">.</span>Right<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实现常见的排序算法</title>
      <link href="/2022/08/29/go-yu-yan-shi-xian-chang-jian-de-pai-xu-suan-fa/"/>
      <url>/2022/08/29/go-yu-yan-shi-xian-chang-jian-de-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><table><thead><tr><th align="left">排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td align="left">选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td align="left">插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td align="left">希尔排序</td><td>O(n㏒n)</td><td>O(n㏒²n)</td><td>O(n㏒²n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td align="left">归并排序</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n)</td><td>稳定</td></tr><tr><td align="left">快速排序</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n²)</td><td>O(㏒n)</td><td>不稳定</td></tr><tr><td align="left">堆排序</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td align="left">计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr></tbody></table><ul><li><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p></li><li><p>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p></li><li><p>时间复杂度: 一个算法执行所耗费的时间。</p></li><li><p>空间复杂度: 运行完一个程序所需内存的大小。</p></li></ul><h2 id="一、-冒泡排序"><a href="#一、-冒泡排序" class="headerlink" title="一、 冒泡排序"></a>一、 冒泡排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 冒泡排序</span><span class="token comment">// 相邻两位交换，把最大数移动到最右边，遍历n次序列。</span><span class="token keyword">func</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 判断序列是否已经有序的标志位，避免无效循环</span>flag <span class="token operator">:=</span> <span class="token boolean">true</span><span class="token comment">// 每轮遍历会把最大值移动到右边</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// true表示序列已经有序，不用继续遍历了</span><span class="token comment">// false表示本次遍历发生了交换，需要继续判断下个循环</span><span class="token keyword">if</span> flag <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、-选择排序"><a href="#二、-选择排序" class="headerlink" title="二、 选择排序"></a>二、 选择排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 选择排序</span><span class="token comment">// 遍历序列找到最小值放最左边，循环遍历剩下的序列。</span><span class="token keyword">func</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>min <span class="token operator">:=</span> i<span class="token keyword">for</span> j <span class="token operator">:=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 如果下标j的值比min小，更新下标min</span><span class="token keyword">if</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>min <span class="token operator">=</span> j<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 遍历一轮序列，最小值发生变化</span><span class="token keyword">if</span> min <span class="token operator">!=</span> i <span class="token punctuation">{</span><span class="token comment">// 交换下标为i,min的值</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、-插入排序"><a href="#三、-插入排序" class="headerlink" title="三、 插入排序"></a>三、 插入排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 插入排序</span><span class="token comment">// 取首元素作为有序队列，把第二位插入到有序队列中，把第三位插入到前两位组成的有序队列中</span><span class="token comment">// 新的一位插入有序队列时，跟他的前一位比较，即有序队列的最右边，依次向前遍历。</span><span class="token keyword">func</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 大于等于有序队列中最大元素，直接插入队尾</span><span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">}</span>temp <span class="token operator">:=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>j <span class="token operator">:=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token comment">//temp &lt; arr[j]，把j向后移位，依次循环，直到temp &gt;= arr[j]</span><span class="token keyword">for</span> <span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 发生了j--，需要j+1</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、-希尔排序"><a href="#四、-希尔排序" class="headerlink" title="四、 希尔排序"></a>四、 希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><pre class="line-numbers language-none"><code class="language-none">// 希尔排序// 按间隔分组，每组进行插入排序。间隔逐渐减小，直到间隔为1func shellSort(arr []int) {length := len(arr)for gap := length / 2; gap &gt; 0; gap /= 2 {for i := gap; i &lt; length; i++ {if arr[i] &gt;= arr[i-gap] {continue}temp := arr[i]j := i - gapfor ; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= gap {arr[j+gap] = arr[j]}arr[j+gap] = temp}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、-归并排序"><a href="#五、-归并排序" class="headerlink" title="五、 归并排序"></a>五、 归并排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 归并排序</span><span class="token comment">// 将长度为n的序列划分成n个长度为1的子序列，两两归并成n/2个长度为2子序列，</span><span class="token comment">// 不断两两归并得到1个长度为n的子序列</span><span class="token keyword">func</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span><span class="token keyword">return</span> arr<span class="token punctuation">}</span>num <span class="token operator">:=</span> length<span class="token operator">/</span><span class="token number">2</span>left <span class="token operator">:=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span>right <span class="token operator">:=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>num<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>l<span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// left或right有一方遍历完则退出循环</span><span class="token keyword">for</span> l <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>l<span class="token operator">++</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>r<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// left和right均为有序，直接将剩余部分加进序列</span><span class="token comment">// 如果上面是left遍历完，left[l:]为[]，right还有剩余值</span><span class="token comment">// 如果上面是right遍历完，right[r:]为[], left还有剩余值</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left<span class="token punctuation">[</span>l<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> right<span class="token punctuation">[</span>r<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、-快速排序"><a href="#六、-快速排序" class="headerlink" title="六、 快速排序"></a>六、 快速排序</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 快速排序(递归版)</span><span class="token comment">// 取首位元素为基准，遍历序列将小于基准的数字放左边，大于基准的数字放右边。递归处理基准左右两个序列</span><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">quick</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> start <span class="token operator">&gt;=</span> end <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 把第一个元素作为基准</span>pivot <span class="token operator">:=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span>i<span class="token punctuation">,</span>j <span class="token operator">:=</span> start<span class="token punctuation">,</span> end<span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token punctuation">{</span><span class="token comment">// 从右往左找小于基准的数字，大于则不处理。不取等会死循环</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">}</span><span class="token comment">// 从左往右找大于基准的数字，小于则不处理</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 如果存在大于基准的数或者小于基准的，移动到i位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 把基准放在i,j重合位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">// 递归处理基准左边的序列</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 递归处理基准右边的序列</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 快速排序(非递归版)</span><span class="token comment">// 需要借助额外空间记录需要快排的序列起点和终点。</span><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 切片模拟栈</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>start<span class="token punctuation">,</span> end <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment">// 一轮快排，将序列中小于基准的移动到左边，大于基准的移动到右边</span>mid <span class="token operator">:=</span> <span class="token function">quick1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token comment">// 长度大于2的子序列才需要继续快排处理</span><span class="token keyword">if</span> start <span class="token operator">&lt;</span> mid<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> end <span class="token operator">&gt;</span> mid<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 遍历栈，直到所有需要快排的序列全部排序完</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>end <span class="token operator">=</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">)</span>start <span class="token operator">=</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">)</span>mid <span class="token operator">=</span> <span class="token function">quick1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token comment">// 长度大于2的子序列才需要继续快排处理</span><span class="token keyword">if</span> start <span class="token operator">&lt;</span> mid<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> end <span class="token operator">&gt;</span> mid<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 模拟栈的push</span><span class="token keyword">func</span> <span class="token function">push</span><span class="token punctuation">(</span>stack <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 模拟栈的pop</span><span class="token keyword">func</span> <span class="token function">pop</span><span class="token punctuation">(</span>stack <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">}</span>res <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">)</span><span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span class="token comment">// 快排处理，将序列中小于基准的移动到左边，大于基准的移动到右边</span><span class="token keyword">func</span> <span class="token function">quick</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token comment">// 把第一个元素作为基准</span>pivot <span class="token operator">:=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span>i<span class="token punctuation">,</span>j <span class="token operator">:=</span> start<span class="token punctuation">,</span> end<span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token punctuation">{</span><span class="token comment">// 从右往左找小于基准的数字，大于则不处理。不取等会死循环</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">}</span><span class="token comment">// 从左往右找大于基准的数字，小于则不处理</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 如果存在大于基准的数或者小于基准的，移动到i位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 把基准放在i,j重合位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">return</span> i<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序可优化点"><a href="#快速排序可优化点" class="headerlink" title="快速排序可优化点"></a>快速排序可优化点</h3><ul><li>时间复杂度优化，基准选择不恰当会导致时间复杂度退化,极限情况下相当于冒泡排序，即复杂度为O(n^2)。可以取多个数字，将中位数作为基准</li><li>递归深度优化，快排会将序列拆分成大量有一定顺序的小区间，此时可以使用插入排序。</li></ul><h2 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 堆排序</span><span class="token comment">// 升序使用大顶堆，降序使用小顶堆</span><span class="token comment">// 根据序列进行建堆，将堆顶元素和末位元素交换，去掉末位，重新调整剩下序列的大顶堆</span><span class="token keyword">func</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">// 调整序列为大顶堆，最后一个非叶子节点(length-1-1)/2</span><span class="token keyword">for</span> i <span class="token operator">:=</span> length<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span><span class="token comment">// 首尾元素交换</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment">// 去掉最大元素，剩下的序列重新调整出大顶堆</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> arr<span class="token punctuation">}</span><span class="token comment">// 调整二叉树为大顶堆</span><span class="token keyword">func</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> length <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 默认i最大</span>largest <span class="token operator">:=</span> i<span class="token comment">// 非叶子节点i的左右孩子</span>left <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span>right <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token comment">//存在左孩子且左孩子大，最大指向left</span><span class="token keyword">if</span> left <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>largest <span class="token operator">=</span> left<span class="token punctuation">}</span><span class="token comment">//存在右孩子且右孩子更大，最大指向right</span><span class="token keyword">if</span> right <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>largest <span class="token operator">=</span> right<span class="token punctuation">}</span><span class="token comment">//最大发生过改变，交换</span><span class="token keyword">if</span> largest <span class="token operator">!=</span> i <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">// 递归维护下一层，直到最后一层非叶子节点</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>largest<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 计数排序</span><span class="token comment">// 需要一个额外空间记录每个元素出现的次数，然乎从小到大把元素放回原数组中</span><span class="token keyword">func</span> <span class="token function">countSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>min<span class="token punctuation">,</span> max <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">// 遍历序列获取最大值和最小，来确认需要申请的空间大小</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">if</span> min <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">if</span> max <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 创建计数器</span>count <span class="token operator">:=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span>bucket <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token comment">// 统计每个元素的个数</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 按元素从小到达放回原数组</span>index <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>bucket<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> minindex<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI七层模型</title>
      <link href="/2022/05/06/osi-can-kao-mo-xing-he-xie-yi-fen-ceng/"/>
      <url>/2022/05/06/osi-can-kao-mo-xing-he-xie-yi-fen-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><h2 id="一、协议分层"><a href="#一、协议分层" class="headerlink" title="一、协议分层"></a>一、协议分层</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>通过分层，使得那些比较复杂的网络协议更加简单化。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>解耦，分层可以将每个分层独立使用，即使系统中某些分层发生了变化，也不会波及到整个系统。</li><li>拓展性和灵活性更强，通过分层能细分通信功能，界定各个分层的具体责任和义务，更易于单独实现每一层的协议。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>可能在于过分模块化，使处理变得更加沉重以及每个模块不得不实现相似的处理逻辑等问题</li></ul><h2 id="二、对分层的理解"><a href="#二、对分层的理解" class="headerlink" title="二、对分层的理解"></a>二、对分层的理解</h2><table><thead><tr><th>OSI参考模型</th><th>功能</th></tr></thead><tbody><tr><td>应用层</td><td>为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登陆等协议。</td></tr><tr><td>表示层</td><td>设备固有数据格式和网络标准数据格式的转换。保证不同设备对同一比特流转换的结果一致。</td></tr><tr><td>会话层</td><td>通信管理，负责建立和断开通信连接，决定数据流动的逻辑通路，以及数据分割等数据传输相关的管理。（只负责决定建立连接和断开连接的时机）</td></tr><tr><td>传输层</td><td>管理两个节点之间的数据传输。确保数据传输的可靠性。（实际建立连接和断开连接处理）</td></tr><tr><td>网络层</td><td>负责寻址和路由选择。将数据发送至最终目标地址</td></tr><tr><td>数据链路层</td><td>通过数据帧和比特流的转换给互联设备之间数据传送。负责实现每个区间内的通信。</td></tr><tr><td>物理层</td><td>比特流和电子信号的转换。界定连接器和网线的规格。</td></tr></tbody></table><h2 id="三、不同层的区别"><a href="#三、不同层的区别" class="headerlink" title="三、不同层的区别"></a>三、不同层的区别</h2><h3 id="3-1-网络层和数据链路层"><a href="#3-1-网络层和数据链路层" class="headerlink" title="3.1 网络层和数据链路层"></a>3.1 网络层和数据链路层</h3><p>网络层和数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址，而数据链路层则只负责发送一个分段内的数据。</p><h3 id="3-2-会话层和传输层"><a href="#3-2-会话层和传输层" class="headerlink" title="3.2 会话层和传输层"></a>3.2 会话层和传输层</h3><p>会话层负责决定建立连接和断开连接的时机，而传输层才是实际建立连接和断开连接的处理。</p><h2 id="四、和TCP-x2F-IP的区别"><a href="#四、和TCP-x2F-IP的区别" class="headerlink" title="四、和TCP/IP的区别"></a>四、和TCP/IP的区别</h2><ul><li>OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更加强调“在计算机上实现协议应该开发哪种程序”。OSI是一个理论上的网络通信”参考”模型，而TCP/IP是实际运行的网络协议。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/16/hello-world/"/>
      <url>/2022/04/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean   <span class="token comment">#清除缓存文件 db.json 和已生成的静态文件 public</span>hexo g       <span class="token comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span>hexo d       <span class="token comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
