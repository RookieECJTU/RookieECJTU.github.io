<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Top K的两种经典解法（堆/快排）与优劣比较</title>
      <link href="/2022/09/13/top-k-de-liang-chong-jing-dian-jie-fa-dui-kuai-pai-yu-you-lie-bi-jiao/"/>
      <url>/2022/09/13/top-k-de-liang-chong-jing-dian-jie-fa-dui-kuai-pai-yu-you-lie-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><p>在n个数中找出最小的k个数。例如，4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><h2 id="方法一：堆"><a href="#方法一：堆" class="headerlink" title="方法一：堆"></a>方法一：堆</h2><ul><li>时间复杂度O(n log k)</li><li>空间复杂度O(k)</li><li>思路：借助一个大小为K的最大堆（大顶堆）。将元素一次入堆，当堆的大小超过k时，将多出的元素从堆顶弹出。处理完所有元素之后，堆里存储的元素即为最小的K个元素。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 从数组中获取最小的k个元素</span><span class="token keyword">func</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&gt;</span> length <span class="token punctuation">{</span><span class="token keyword">return</span> res<span class="token punctuation">}</span>pq <span class="token operator">:=</span> <span class="token operator">&amp;</span>maxHeap<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>heap<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span>heap<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 遍历到的元素比堆顶元素小时，取出堆顶元素，将当前元素入堆</span><span class="token keyword">if</span> pq<span class="token punctuation">.</span><span class="token function">Peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>heap<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span>heap<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>pq<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> heap<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span>pq<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span class="token comment">// 基于go interface实现最大堆</span><span class="token keyword">type</span> maxHeap <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>x <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>h <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">,</span> x<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>h<span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>h<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span>h<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 查看堆顶元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> <span class="token function">Peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：基于快速排序的数组划分"><a href="#方法二：基于快速排序的数组划分" class="headerlink" title="方法二：基于快速排序的数组划分"></a>方法二：基于快速排序的数组划分</h2><ul><li>时间复杂度O(n)，最坏情况为o(n^2)</li><li>空间复杂度O(log n)</li><li>思路：题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而快速排序的基准元素划分可完成此目标。<br>根据快速排序原理，会把比基准元素小的元素放左边，比基准元素大的放右边。假设基准元素下标为m，那么：<blockquote><ul><li>如果 k == m，则基准元素左边正好有且只有k个比基准小的元素</li><li>如果 k &lt; m，则基准左边小元素数量不够，只需要继续递归基准右边的元素</li><li>如果 k &gt; m，则基准左边元素超过了k个，只需要递归基准左边的元素即可</li></ul></blockquote></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 从数组中获取最小的k个元素</span><span class="token keyword">func</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&gt;</span> length <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">quick</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> k <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> start <span class="token operator">&gt;=</span> end <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 把第一个元素作为基准</span>pivot <span class="token operator">:=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span>i<span class="token punctuation">,</span>j <span class="token operator">:=</span> start<span class="token punctuation">,</span> end<span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token punctuation">{</span><span class="token comment">// 从右往左找小于基准的数字，大于则不处理。不取等会死循环</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">}</span><span class="token comment">// 从左往右找大于基准的数字，小于则不处理</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 如果存在大于基准的数或者小于基准的，移动到i位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 把基准放在i,j重合位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">// 如果k &lt; i 则需要把i右边的数组继续排序，如果 k &gt; i 则需要把i左边的数组继续排序</span><span class="token comment">// 如果k == i 则说明i左边正好有k个最小元素了，直接返回</span><span class="token keyword">if</span> k <span class="token operator">&lt;</span> i <span class="token punctuation">{</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> k <span class="token operator">&gt;</span> i <span class="token punctuation">{</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两种方法的优缺点比较"><a href="#两种方法的优缺点比较" class="headerlink" title="两种方法的优缺点比较"></a>两种方法的优缺点比较</h2><p>虽然方法二的时间复杂度优于方法一，但是快速排序算法有以下几点局限性</p><ol><li>方法二需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</li><li>算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的数据结构-压缩列表</title>
      <link href="/2022/09/02/redis-de-shu-ju-jie-gou-ya-suo-lie-biao/"/>
      <url>/2022/09/02/redis-de-shu-ju-jie-gou-ya-suo-lie-biao/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的数据结构-整数集合</title>
      <link href="/2022/09/02/redis-de-shu-ju-jie-gou-zheng-shu-ji-he/"/>
      <url>/2022/09/02/redis-de-shu-ju-jie-gou-zheng-shu-ji-he/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的数据结构-跳跃表</title>
      <link href="/2022/09/02/redis-de-shu-ju-jie-gou-tiao-yue-biao/"/>
      <url>/2022/09/02/redis-de-shu-ju-jie-gou-tiao-yue-biao/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis的设计与实现-字典</title>
      <link href="/2022/09/02/redis-she-ji-yu-shi-xian-zi-dian/"/>
      <url>/2022/09/02/redis-she-ji-yu-shi-xian-zi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典，又称符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。<br>在字典中，一个键可以和一个值进行关联，每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或通过键来更新值，又或者根据键来删除整个键值对，等等。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Redis字典所使用的哈希表由dict.h/dictht结构定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">{</span>   <span class="token comment">// 哈希表数组 </span>  dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>  <span class="token comment">// 哈希表大小</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size   <span class="token comment">// 哈希表大小掩码，用于计算索引值</span>  <span class="token comment">// 总是等于size-1</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask   <span class="token comment">// 该哈希表已有节点的数量</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>table属性是一个数组，数组中的每个元素都是指向dict.h/dictEntry结构的指针</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的数据结构-链表</title>
      <link href="/2022/09/02/redis-de-shu-ju-jie-gou-lian-biao/"/>
      <url>/2022/09/02/redis-de-shu-ju-jie-gou-lian-biao/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis设计与实现-redis字符串实现</title>
      <link href="/2022/09/02/redis-she-ji-yu-shi-xian-redis-zi-fu-chuan-shi-xian/"/>
      <url>/2022/09/02/redis-she-ji-yu-shi-xian-redis-zi-fu-chuan-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis字符串实现"><a href="#一、Redis字符串实现" class="headerlink" title="一、Redis字符串实现"></a>一、Redis字符串实现</h2><p>Redis没有使用C语言传统的字符串表示（以空字符串结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。<br>例如，如果客户端执行命令</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">redis<span class="token operator">&gt;</span> SET msg <span class="token string">"hello world"</span>OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么Redis将在数据库中创建一个新的键值对，其中：</p><ul><li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg”的SDS</li><li>键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串”hello world”的SDS</li></ul><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><p>每个sds.h/sdshdr结构表示一个SDS值：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>   <span class="token comment">// 记录buf数组中已使用字节的数量 </span>  <span class="token comment">// 等于SDS所保存字符串的长度 </span>  <span class="token keyword">int</span> len<span class="token punctuation">;</span>   <span class="token comment">// 记录buf数组中未使用字节的数量 </span>  <span class="token keyword">int</span> free<span class="token punctuation">;</span>   <span class="token comment">// 字节数组，用于保存字符串 </span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：SDS遵循C字符串以’\0’结尾的惯例，保存’\0’的一个字节空间不会计算在SDS的len属性里面，并且为’\0’分配额外的1字节空间以及添加’\0’到字符串末尾等操作都是由SDS函数自动完成的，所以这个空字符串对于SDS的使用者来说是完全透明的。遵循’\0’结尾的好处是SDS可以直接重用一部分C字符串函数库里面的函数。</p><h2 id="二、C字符串和SDS的区别"><a href="#二、C字符串和SDS的区别" class="headerlink" title="二、C字符串和SDS的区别"></a>二、C字符串和SDS的区别</h2><table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度Ｎ次必然需要执行Ｎ次内存重分配</td><td>修改字符串Ｎ次最多需要执行Ｎ次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本数据或者二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库的函数</td><td>可以使用一部分&lt;string.h&gt;库的函数</td></tr></tbody></table><h2 id="三、空间预分配和惰性空间释放"><a href="#三、空间预分配和惰性空间释放" class="headerlink" title="三、空间预分配和惰性空间释放"></a>三、空间预分配和惰性空间释放</h2><p>对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是N+1个字符长的数组。因为C字符串的长度和底层数组的长度之间存在这种关联性，所以每次增长或者缩短一个C字符串都需要对保存这个C字符串的数组进行一次内存重分配操作：</p><ul><li>如果程序执行增长字符串操作，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步会产生缓冲区溢出</li><li>如果程序执行缩短字符串操作，程序需要先通过内存重分配来释放不在使用的那部分空间——如果忘了这一步会产生内存泄露</li></ul><p>因为内存重分配涉及复杂的算法，并且可能需要执行系统的调用，所以它通常是一个比较耗时的操作。为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p><h3 id="3-1-空间预分配"><a href="#3-1-空间预分配" class="headerlink" title="3.1 空间预分配"></a>3.1 空间预分配</h3><p>空间预分配用于优化SDS字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用的空间。<br>其中，额外分配的未使用空间数量由以下公式决定：</p><ul><li>如果对SDS进行修改之后，SDS的长度（即len属性的值）将小于1MB，那么程序分配和len属性相同的未使用空间，这时SDS的len属性的值将和free属性的值相同。例如：进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存’\0’）。</li><li>如果对SDS进行修改之后，SDS的长度大于1MB，那么程序将会分配1MB的未使用空间。例如：进行修改之后，SDS的len将变成30MB，那么程序也会分配1MB的未使用空间，SDS的buf数组的实际长度将变成30MB + 1MB + 1byte。</li></ul><p>在扩展SDS空间之前，SDS的API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用的空间，则无需执行内存重分配。</p><h3 id="3-2-惰性空间释放"><a href="#3-2-惰性空间释放" class="headerlink" title="3.2 惰性空间释放"></a>3.2 惰性空间释放</h3><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不会立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。<br>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。</p><h2 id="四、二进制安全"><a href="#四、二进制安全" class="headerlink" title="四、二进制安全"></a>四、二进制安全</h2><p>C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串不能包含’\0’,否则最先被程序读入的’\0’会被误认是字符串的结尾，这些限制使得C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。<br>SDS使用len属性的值而不是’\0’判断字符串是否结束，SDS API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式处理SDS存放在buf数组里的数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实现前中后序遍历构建二叉树</title>
      <link href="/2022/08/30/bian-li-er-cha-shu/"/>
      <url>/2022/08/30/bian-li-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 前序遍历（递归版）</span><span class="token comment">// 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</span><span class="token keyword">func</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 先放入根节点，然后递归左节点</span>res <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>root<span class="token punctuation">.</span>Val<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 然后递归右节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 前序遍历（迭代版）</span><span class="token comment">// 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树。借助栈来模拟递归</span><span class="token keyword">func</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 记录前序遍历结果</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 借助栈来模拟递归</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// 从栈中取出一个节点</span>node <span class="token operator">:=</span> stack<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token comment">// 放入根节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token comment">// 先左节点后右节点放入栈中,这样会”中-&gt;左-&gt;右“的顺序</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 后序遍历（递归版）</span><span class="token comment">// 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</span><span class="token keyword">func</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 先递归左节点</span><span class="token comment">// 然后递归右节点</span>res <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 然后放入根节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> root<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代版-1"><a href="#迭代版-1" class="headerlink" title="迭代版"></a>迭代版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 后序遍历（迭代版）</span><span class="token comment">// 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点。借助栈来模拟递归，逻辑和前序遍历一样，但需要反向生成结果数组。</span><span class="token keyword">func</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 记录前序遍历结果</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 借助栈来模拟递归</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// 从栈中取出一个节点</span>node <span class="token operator">:=</span> stack<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token comment">// 放入根节点，反向生成结果数组</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>node<span class="token punctuation">.</span>Val<span class="token punctuation">}</span><span class="token punctuation">,</span> res<span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">// 先左节点后右节点放入栈中,这样会”中-&gt;右-&gt;左“的顺序，然后反向生成结果数字</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 中序遍历（递归版）</span><span class="token comment">// 中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</span><span class="token keyword">func</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 先递归左节点</span><span class="token comment">// 然后放入根节点</span>res <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token comment">// 然后递归右节点</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代版-2"><a href="#迭代版-2" class="headerlink" title="迭代版"></a>迭代版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TreeNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>Val <span class="token builtin">int</span>Left <span class="token operator">*</span>TreeNodeRight <span class="token operator">*</span>TreeNode<span class="token punctuation">}</span><span class="token comment">// 中序遍历（迭代版版）</span><span class="token comment">// 中序遍历：左子树 —&gt; 根结点 —&gt; 右子树</span><span class="token comment">// 遍历顺序和处理节点的顺序不同，导致中序遍历和前序遍历和后序遍历都不一样。</span><span class="token comment">// 需要借助一个栈来记录遍历过的节点，需要一个指针来记录当前节点</span><span class="token keyword">func</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 创建一个栈来记录遍历过的节点</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 指针初始化指向根节点</span>cur <span class="token operator">:=</span> root<span class="token keyword">for</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">if</span> cur <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token comment">// 记录遍历过的节点</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token comment">// 当前指针指向左子节点</span>cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>Left<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 取出栈顶元素</span>node <span class="token operator">:=</span> stack<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment">// 放入结果数组中</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> node<span class="token punctuation">.</span>Val<span class="token punctuation">)</span><span class="token comment">// 当前指针指向右子节点</span>cur <span class="token operator">=</span> node<span class="token punctuation">.</span>Right<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实现常见的排序算法</title>
      <link href="/2022/08/29/go-yu-yan-shi-xian-chang-jian-de-pai-xu-suan-fa/"/>
      <url>/2022/08/29/go-yu-yan-shi-xian-chang-jian-de-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><table><thead><tr><th align="left">排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td align="left">选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td align="left">插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td></tr><tr><td align="left">希尔排序</td><td>O(n㏒n)</td><td>O(n㏒²n)</td><td>O(n㏒²n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td align="left">归并排序</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n)</td><td>稳定</td></tr><tr><td align="left">快速排序</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n²)</td><td>O(㏒n)</td><td>不稳定</td></tr><tr><td align="left">堆排序</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(n㏒n)</td><td>O(1)</td><td>不稳定</td></tr><tr><td align="left">计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>稳定</td></tr></tbody></table><ul><li><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p></li><li><p>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p></li><li><p>时间复杂度: 一个算法执行所耗费的时间。</p></li><li><p>空间复杂度: 运行完一个程序所需内存的大小。</p></li></ul><h2 id="一、-冒泡排序"><a href="#一、-冒泡排序" class="headerlink" title="一、 冒泡排序"></a>一、 冒泡排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 冒泡排序</span><span class="token comment">// 相邻两位交换，把最大数移动到最右边，遍历n次序列。</span><span class="token keyword">func</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 判断序列是否已经有序的标志位，避免无效循环</span>flag <span class="token operator">:=</span> <span class="token boolean">true</span><span class="token comment">// 每轮遍历会把最大值移动到右边</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// true表示序列已经有序，不用继续遍历了</span><span class="token comment">// false表示本次遍历发生了交换，需要继续判断下个循环</span><span class="token keyword">if</span> flag <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、-选择排序"><a href="#二、-选择排序" class="headerlink" title="二、 选择排序"></a>二、 选择排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 选择排序</span><span class="token comment">// 遍历序列找到最小值放最左边，循环遍历剩下的序列。</span><span class="token keyword">func</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>min <span class="token operator">:=</span> i<span class="token keyword">for</span> j <span class="token operator">:=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 如果下标j的值比min小，更新下标min</span><span class="token keyword">if</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>min <span class="token operator">=</span> j<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 遍历一轮序列，最小值发生变化</span><span class="token keyword">if</span> min <span class="token operator">!=</span> i <span class="token punctuation">{</span><span class="token comment">// 交换下标为i,min的值</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、-插入排序"><a href="#三、-插入排序" class="headerlink" title="三、 插入排序"></a>三、 插入排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 插入排序</span><span class="token comment">// 取首元素作为有序队列，把第二位插入到有序队列中，把第三位插入到前两位组成的有序队列中</span><span class="token comment">// 新的一位插入有序队列时，跟他的前一位比较，即有序队列的最右边，依次向前遍历。</span><span class="token keyword">func</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 大于等于有序队列中最大元素，直接插入队尾</span><span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">}</span>temp <span class="token operator">:=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>j <span class="token operator">:=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token comment">//temp &lt; arr[j]，把j向后移位，依次循环，直到temp &gt;= arr[j]</span><span class="token keyword">for</span> <span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 发生了j--，需要j+1</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、-希尔排序"><a href="#四、-希尔排序" class="headerlink" title="四、 希尔排序"></a>四、 希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><pre class="line-numbers language-none"><code class="language-none">// 希尔排序// 按间隔分组，每组进行插入排序。间隔逐渐减小，直到间隔为1func shellSort(arr []int) {length := len(arr)for gap := length / 2; gap &gt; 0; gap /= 2 {for i := gap; i &lt; length; i++ {if arr[i] &gt;= arr[i-gap] {continue}temp := arr[i]j := i - gapfor ; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= gap {arr[j+gap] = arr[j]}arr[j+gap] = temp}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、-归并排序"><a href="#五、-归并排序" class="headerlink" title="五、 归并排序"></a>五、 归并排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 归并排序</span><span class="token comment">// 将长度为n的序列划分成n个长度为1的子序列，两两归并成n/2个长度为2子序列，</span><span class="token comment">// 不断两两归并得到1个长度为n的子序列</span><span class="token keyword">func</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span><span class="token keyword">return</span> arr<span class="token punctuation">}</span>num <span class="token operator">:=</span> length<span class="token operator">/</span><span class="token number">2</span>left <span class="token operator">:=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span>right <span class="token operator">:=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>num<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>l<span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>res <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// left或right有一方遍历完则退出循环</span><span class="token keyword">for</span> l <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>l<span class="token operator">++</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>r<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// left和right均为有序，直接将剩余部分加进序列</span><span class="token comment">// 如果上面是left遍历完，left[l:]为[]，right还有剩余值</span><span class="token comment">// 如果上面是right遍历完，right[r:]为[], left还有剩余值</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left<span class="token punctuation">[</span>l<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> right<span class="token punctuation">[</span>r<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、-快速排序"><a href="#六、-快速排序" class="headerlink" title="六、 快速排序"></a>六、 快速排序</h2><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 快速排序(递归版)</span><span class="token comment">// 取首位元素为基准，遍历序列将小于基准的数字放左边，大于基准的数字放右边。递归处理基准左右两个序列</span><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">quick</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> start <span class="token operator">&gt;=</span> end <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 把第一个元素作为基准</span>pivot <span class="token operator">:=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span>i<span class="token punctuation">,</span>j <span class="token operator">:=</span> start<span class="token punctuation">,</span> end<span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token punctuation">{</span><span class="token comment">// 从右往左找小于基准的数字，大于则不处理。不取等会死循环</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">}</span><span class="token comment">// 从左往右找大于基准的数字，小于则不处理</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 如果存在大于基准的数或者小于基准的，移动到i位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 把基准放在i,j重合位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">// 递归处理基准左边的序列</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 递归处理基准右边的序列</span><span class="token function">quick</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 快速排序(非递归版)</span><span class="token comment">// 需要借助额外空间记录需要快排的序列起点和终点。</span><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 切片模拟栈</span>stack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>start<span class="token punctuation">,</span> end <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment">// 一轮快排，将序列中小于基准的移动到左边，大于基准的移动到右边</span>mid <span class="token operator">:=</span> <span class="token function">quick1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token comment">// 长度大于2的子序列才需要继续快排处理</span><span class="token keyword">if</span> start <span class="token operator">&lt;</span> mid<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> end <span class="token operator">&gt;</span> mid<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 遍历栈，直到所有需要快排的序列全部排序完</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>end <span class="token operator">=</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">)</span>start <span class="token operator">=</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">)</span>mid <span class="token operator">=</span> <span class="token function">quick1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token comment">// 长度大于2的子序列才需要继续快排处理</span><span class="token keyword">if</span> start <span class="token operator">&lt;</span> mid<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> end <span class="token operator">&gt;</span> mid<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 模拟栈的push</span><span class="token keyword">func</span> <span class="token function">push</span><span class="token punctuation">(</span>stack <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 模拟栈的pop</span><span class="token keyword">func</span> <span class="token function">pop</span><span class="token punctuation">(</span>stack <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">)</span><span class="token keyword">if</span> length <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">}</span>res <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">)</span><span class="token punctuation">[</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>stack<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">return</span> res<span class="token punctuation">}</span><span class="token comment">// 快排处理，将序列中小于基准的移动到左边，大于基准的移动到右边</span><span class="token keyword">func</span> <span class="token function">quick</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token comment">// 把第一个元素作为基准</span>pivot <span class="token operator">:=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span>i<span class="token punctuation">,</span>j <span class="token operator">:=</span> start<span class="token punctuation">,</span> end<span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token punctuation">{</span><span class="token comment">// 从右往左找小于基准的数字，大于则不处理。不取等会死循环</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">}</span><span class="token comment">// 从左往右找大于基准的数字，小于则不处理</span><span class="token keyword">for</span> i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 如果存在大于基准的数或者小于基准的，移动到i位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">// 把基准放在i,j重合位置</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">return</span> i<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序可优化点"><a href="#快速排序可优化点" class="headerlink" title="快速排序可优化点"></a>快速排序可优化点</h3><ul><li>时间复杂度优化，基准选择不恰当会导致时间复杂度退化,极限情况下相当于冒泡排序，即复杂度为O(n^2)。可以取多个数字，将中位数作为基准</li><li>递归深度优化，快排会将序列拆分成大量有一定顺序的小区间，此时可以使用插入排序。</li></ul><h2 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 堆排序</span><span class="token comment">// 升序使用大顶堆，降序使用小顶堆</span><span class="token comment">// 根据序列进行建堆，将堆顶元素和末位元素交换，去掉末位，重新调整剩下序列的大顶堆</span><span class="token keyword">func</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">// 调整序列为大顶堆，最后一个非叶子节点(length-1-1)/2</span><span class="token keyword">for</span> i <span class="token operator">:=</span> length<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span><span class="token comment">// 首尾元素交换</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment">// 去掉最大元素，剩下的序列重新调整出大顶堆</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> arr<span class="token punctuation">}</span><span class="token comment">// 调整二叉树为大顶堆</span><span class="token keyword">func</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> length <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 默认i最大</span>largest <span class="token operator">:=</span> i<span class="token comment">// 非叶子节点i的左右孩子</span>left <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span>right <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token comment">//存在左孩子且左孩子大，最大指向left</span><span class="token keyword">if</span> left <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>largest <span class="token operator">=</span> left<span class="token punctuation">}</span><span class="token comment">//存在右孩子且右孩子更大，最大指向right</span><span class="token keyword">if</span> right <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>largest <span class="token operator">=</span> right<span class="token punctuation">}</span><span class="token comment">//最大发生过改变，交换</span><span class="token keyword">if</span> largest <span class="token operator">!=</span> i <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">// 递归维护下一层，直到最后一层非叶子节点</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>largest<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 计数排序</span><span class="token comment">// 需要一个额外空间记录每个元素出现的次数，然乎从小到大把元素放回原数组中</span><span class="token keyword">func</span> <span class="token function">countSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>min<span class="token punctuation">,</span> max <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">// 遍历序列获取最大值和最小，来确认需要申请的空间大小</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">if</span> min <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">if</span> max <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 创建计数器</span>count <span class="token operator">:=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span>bucket <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token comment">// 统计每个元素的个数</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">}</span><span class="token comment">// 按元素从小到达放回原数组</span>index <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>bucket<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> minindex<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议分层模型</title>
      <link href="/2022/08/06/tcp-ip-xie-yi-fen-ceng-mo-xing/"/>
      <url>/2022/08/06/tcp-ip-xie-yi-fen-ceng-mo-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI七层模型</title>
      <link href="/2022/05/06/osi-can-kao-mo-xing-he-xie-yi-fen-ceng/"/>
      <url>/2022/05/06/osi-can-kao-mo-xing-he-xie-yi-fen-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><h2 id="一、协议分层"><a href="#一、协议分层" class="headerlink" title="一、协议分层"></a>一、协议分层</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>通过分层，使得那些比较复杂的网络协议更加简单化。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>解耦，分层可以将每个分层独立使用，即使系统中某些分层发生了变化，也不会波及到整个系统。</li><li>拓展性和灵活性更强，通过分层能细分通信功能，界定各个分层的具体责任和义务，更易于单独实现每一层的协议。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>可能在于过分模块化，使处理变得更加沉重以及每个模块不得不实现相似的处理逻辑等问题</li></ul><h2 id="二、对分层的理解"><a href="#二、对分层的理解" class="headerlink" title="二、对分层的理解"></a>二、对分层的理解</h2><table><thead><tr><th>OSI参考模型</th><th>功能</th></tr></thead><tbody><tr><td>应用层</td><td>为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登陆等协议。</td></tr><tr><td>表示层</td><td>设备固有数据格式和网络标准数据格式的转换。保证不同设备对同一比特流转换的结果一致。</td></tr><tr><td>会话层</td><td>通信管理，负责建立和断开通信连接，决定数据流动的逻辑通路，以及数据分割等数据传输相关的管理。（只负责决定建立连接和断开连接的时机）</td></tr><tr><td>传输层</td><td>管理两个节点之间的数据传输。确保数据传输的可靠性。（实际建立连接和断开连接处理）</td></tr><tr><td>网络层</td><td>负责寻址和路由选择。将数据发送至最终目标地址</td></tr><tr><td>数据链路层</td><td>通过数据帧和比特流的转换给互联设备之间数据传送。负责实现每个区间内的通信。</td></tr><tr><td>物理层</td><td>比特流和电子信号的转换。界定连接器和网线的规格。</td></tr></tbody></table><h2 id="三、不同层的区别"><a href="#三、不同层的区别" class="headerlink" title="三、不同层的区别"></a>三、不同层的区别</h2><h3 id="3-1-网络层和数据链路层"><a href="#3-1-网络层和数据链路层" class="headerlink" title="3.1 网络层和数据链路层"></a>3.1 网络层和数据链路层</h3><p>网络层和数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址，而数据链路层则只负责发送一个分段内的数据。</p><h3 id="3-2-会话层和传输层"><a href="#3-2-会话层和传输层" class="headerlink" title="3.2 会话层和传输层"></a>3.2 会话层和传输层</h3><p>会话层负责决定建立连接和断开连接的时机，而传输层才是实际建立连接和断开连接的处理。</p><h2 id="四、和TCP-x2F-IP的区别"><a href="#四、和TCP-x2F-IP的区别" class="headerlink" title="四、和TCP/IP的区别"></a>四、和TCP/IP的区别</h2><ul><li>OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更加强调“在计算机上实现协议应该开发哪种程序”。OSI是一个理论上的网络通信”参考”模型，而TCP/IP是实际运行的网络协议。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/16/hello-world/"/>
      <url>/2022/04/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
